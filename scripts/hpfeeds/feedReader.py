#!/usr/bin/env python
# -- coding: utf-8 --
import sys
import os
sPath = os.path.dirname(os.path.realpath(__file__))+'/'
sys.path.append(sPath+'../')
from malwarez_util import init_path

init_path()

import json
import string
import traceback
from Queue import Queue, Empty
import threading
from threading import Thread
from socketIO_client import SocketIO
import freegeoip
import hpfeeds

socketIOHost = '127.0.0.1'
socketIOPort = 80

# Set the DJANGO_SETTINGS_MODULE environment variable.
os.environ['DJANGO_SETTINGS_MODULE'] = "malwarez.settings"
from web.models import Feed

IS_RUNNING = None
client = None

database_queue = Queue(50)
socket_queue = Queue(50)

threads = []


def socket_thread():
    """
    Reads the socket_queue and fill the geo location info(lat, long, city, country) then send new updated
    data to server. After sending to server put the updated feed object to database_queue
    """

    def __to_json(_new_feed):
        return '{ "url":"%s", "saddr":"%s", "sport":"%s", "sha512":"%s", "md5":"%s", ' \
               '"country":"%s", "city":"%s", "x": "%f", "y": "%f"}' \
               % (_new_feed.url, _new_feed.saddr, _new_feed.sport, _new_feed.sha512, _new_feed.md5,
                  _new_feed.country, _new_feed.city, _new_feed.longitude, _new_feed.latitude)

    def _send_new_feed(c_socket, _new_feed):
        info = freegeoip.get_city_info_by_ip(_new_feed.saddr)
        if info:
            _new_feed.longitude = info['longitude']
            _new_feed.latitude = info['latitude']
            _new_feed.country = info['country_code3']

            city = info['city']
            if city:
                try:
                    city = city.decode('utf-8', 'ignore')
                except:
                    city = ''

                _new_feed.city = city

            # TODO: Add other options except for daddr
            coordinate = __to_json(_new_feed)
            c_socket.emit('update', coordinate)
            database_queue.put(_new_feed)

    try:
        socket_io = SocketIO(socketIOHost, socketIOPort)
        chat_socket = socket_io.connect('/new-event')
        print 'socket_thread started, IS_RUNNING:', IS_RUNNING
        while IS_RUNNING:
            try:
                new_feed = socket_queue.get(True, 1)
                _send_new_feed(chat_socket, new_feed)
                socket_queue.task_done()
            except Empty:
                pass
    except:
        traceback.print_exc()
        stop_execution()

    print 'socket_thread finished...'


def database_thread():
    """
    Reads the database_queue and save the object to db. After the operation object will be discarded.
    """
    print 'database_thread started, IS_RUNNING:', IS_RUNNING
    while IS_RUNNING:
        try:
            new_feed = database_queue.get(True, 1)
            new_feed.save()
            database_queue.task_done()
            del new_feed
        except Empty:
            pass
        except:
            traceback.print_exc()
            stop_execution()
            break

    print 'database_thread finished...'


def hpfeeds_thread():
    account_file = open(sPath+'hpfriends.json')
    account = json.load(account_file)

    opts = {
        'IDENT': str(account['user']),
        'SECRET': str(account['pass']),
        'HOST': str(account['host']),
        'PORT': account['port'],
        'CHANNELS': account['capture']
    }

    client = FeedClient(opts)
    print 'hpfeeds_thread started, IS_RUNNING:', IS_RUNNING
    try:
        client.run()
    except:
        print 'client.run() exception'
        traceback.print_exc()

    stop_execution()
    print 'finishing hpfeeds_thread'


class FeedClient(object):
    """
    This class is responsible for fetching new feeds from hpfriends and sends it to socket_queue
    """

    def __init__(self, opts):
        self.host = opts['HOST']
        self.port = opts['PORT']
        self.ident = opts['IDENT']
        self.secret = opts['SECRET']
        self.channels = opts['CHANNELS']
        self.hpc = None

    def log(self, text):
        # TODO: Replace this function with a proper logging function
        print 'log:', text

    def stop(self):
        if self.hpc:
            self.hpc.stop()
            self.hpc.close()

    def run(self):
        """
        Fetches feed from hpfriends and create a Feed object then put it to socket_queue
        """

        global IS_RUNNING

        try:
            self.hpc = hpfeeds.new(self.host, self.port, self.ident, self.secret)
        except hpfeeds.FeedException, e:
            self.log('Error: {0}'.format(e))
            return 1
        self.log('connected to {0}'.format(self.hpc.brokername))

        def on_message(ident, chan, payload):
            self.log("ident: {0}, chan: {1}, payload: {2}".format(ident, chan, payload))

            if [i for i in payload[:20] if i not in string.printable]:
                # TODO: Can be improved?
                pass
            else:
                payload = "{0}".format(payload)
                data = json.loads(payload)
                del payload
                new_feed = Feed(url=data['url'], daddr=data['daddr'],
                                saddr=data['saddr'], sport=data['sport'],
                                dport=data['dport'], sha512=data['sha512'],
                                md5=data['md5'], longitude=-1,
                                latitude=-1, city=u'', country=u'')

                socket_queue.put(new_feed)

        def on_error(payload):
            self.log('Error message from broker: {0}'.format(payload))
            self.hpc.stop()

        self.hpc.subscribe(self.channels)
        try:
            self.hpc.run(on_message, on_error)
        except hpfeeds.FeedException, e:
            self.log('Error: {0}'.format(e))
            # traceback.print_exc()
            IS_RUNNING = False
            return 1

        self.log('closing connection.')
        self.hpc.close()
        return 0


def start_threads():
    global IS_RUNNING

    IS_RUNNING = True

    t = Thread(target=hpfeeds_thread)
    t.daemon = True
    threads.append(t)
    t.start()

    t = Thread(target=database_thread)
    t.daemon = True
    threads.append(t)
    t.start()

    t = Thread(target=socket_thread)
    t.daemon = True
    threads.append(t)
    t.start()

    return threads


stopExecutionStartedFlag = False
stopLock = None


def stop_execution():
    # TODO: This must be thread
    global IS_RUNNING, stopExecutionStartedFlag

    stopLock.acquire()
    if stopExecutionStartedFlag:
        # Already executed, No need to repeat
        stopLock.release()
        return
    stopExecutionStartedFlag = True
    stopLock.release()
    IS_RUNNING = False

    def __wait_for_threads():
        if client:
            print 'stopping client...'
            client.stop()

        print 'waiting...'
        try:
            for _t in threads:
                _t.join()
        except:
            traceback.print_exc()

        print 'del...'
        del database_queue
        del socket_queue

    t = Thread(target=__wait_for_threads)
    t.start()


if __name__ == '__main__':
    import signal

    stopLock = threading.Lock()

    def signal_handler(sig, frame):
        print 'You pressed Ctrl+C! [sig:', sig, ', frame:', frame, ']'
        stop_execution()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    print 'Press Ctrl+C to stop'
    threads = start_threads()
    signal.pause()