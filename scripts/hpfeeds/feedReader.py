#!/usr/bin/python
# -- coding: utf-8 --
import json
import sys
import os
import string
import traceback
from Queue import Queue, Empty, Full
from threading import Thread

sPath=os.path.dirname(os.path.realpath(__file__))+'/'
sys.path.append(sPath+'../../../lib/python2.7/site-packages/')
sys.path.append(sPath+'../freegeoip/')
sys.path.append(sPath+'../../')

from socketIO_client import SocketIO
import freegeoip
import hpfeeds

# Set the DJANGO_SETTINGS_MODULE environment variable.
os.environ['DJANGO_SETTINGS_MODULE'] = "malwarez.settings"
from web.models import Feed

IS_RUNNING = None

databaseQueue = Queue(250)
socketQueue = Queue(250)

def socketThread():
    """
    Reads the socketQueue and fill the geo location info(lat, long, city, country) then send new updated
    data to server. After sending to server put the updated feed object to databaseQueue
    """
    global socketQueue, databaseQueue, IS_RUNNING

    def _sendNewFeed(chatSocket, newFeed):
        info = freegeoip.getCityInfoByIp(newFeed.saddr)
        if info:
            newFeed.longitude = info['longitude']
            newFeed.latitude = info['latitude']
            newFeed.country = info['country_code3']

            city = info['city']
            if city:
                try:
                    city = city.decode('utf-8', 'ignore')
                except:
                    city = ''

                newFeed.city = city

            coordinate = "{ \"country\":\"%s\", \"city\":\"%s\", \"x\": \"%f\", \"y\": \"%f\"}" % (newFeed.country, newFeed.city, info['longitude'], info['latitude'])
            chatSocket.emit('update', coordinate)
            databaseQueue.put(newFeed)

    socketIO = SocketIO('127.0.0.1', 80)
    chatSocket = socketIO.connect('/new-event')
    print 'socketThread started, IS_RUNNING:', IS_RUNNING
    while IS_RUNNING:
        try:
            newFeed = socketQueue.get(True, 1)
            _sendNewFeed(chatSocket, newFeed)
            socketQueue.task_done()
        except Empty:
            pass
        except:
            IS_RUNNING = False

    print 'finishing socketThread'


def databaseThread():
    """
    Reads the databaseQueue and save the object to db. After the operation object will be discarded.
    """
    global databaseQueue, IS_RUNNING

    print 'databaseThread started, IS_RUNNING:', IS_RUNNING
    while IS_RUNNING:
        try:
            newFeed = databaseQueue.get(True, 1)
            newFeed.save()
            databaseQueue.task_done()
            del newFeed
        except Empty:
            pass
        except:
            IS_RUNNING = False

    print 'finishing databaseThread'

def hpfeedsThread():
    global socketQueue, IS_RUNNING
    accountFile = open(sPath+'hpfriends.json', 'r')
    account = json.load(accountFile)

    opts = {
        'IDENT': str(account['user']),
        'SECRET': str(account['pass']),
        'HOST': str(account['host']),
        'PORT': account['port'],
        'CHANNELS': account['capture']
    }

    client = FeedClient(opts)
    print 'hpfeedsThread started, IS_RUNNING:', IS_RUNNING
    try:
        client.run()
    except:
        traceback.print_exc()

    IS_RUNNING = False
    print 'finishing hpfeedsThread'


class FeedClient():
    """
    This class is responsible for fetching new feeds from hpfriends and sends it to socketQueue
    """
    def __init__(self, opts):
        self.host = opts['HOST']
        self.port = opts['PORT']
        self.ident = opts['IDENT']
        self.secret = opts['SECRET']
        self.channels = opts['CHANNELS']

    def log(self, text):
        # TODO: Replace this function with a proper logging function
        print 'log:', text

    def run(self):
        """
        Fetches feed from hpfriends and create a Feed object then put it to socketQueue
        """
        global IS_RUNNING

        try:
            hpc = hpfeeds.new(self.host, self.port, self.ident, self.secret)
        except hpfeeds.FeedException, e:
            self.log('Error: {0}'.format(e))
            return 1
        self.log('connected to {0}'.format(hpc.brokername))

        def on_message(ident, chan, payload):
            global databaseQueue, socketQueue
            if [i for i in payload[:20] if i not in string.printable]:
                # TODO: Can be improved?
                pass
            else:
                payload = "{0}".format(payload)
                data = json.loads(payload)
                del payload
                newFeed = Feed(url=data['url'], daddr=data['daddr'],
                                saddr=data['saddr'], sport=data['sport'],
                                dport=data['dport'], sha512=data['sha512'],
                                md5=data['md5'], longitude=-1,
                                latitude=-1, city=u'', country=u'')

                socketQueue.put(newFeed)


        def on_error(payload):
            self.log('Error message from broker: {0}'.format(payload))
            hpc.stop()

        hpc.subscribe(self.channels)
        try:
            hpc.run(on_message, on_error)
        except hpfeeds.FeedException, e:
            self.log('Error: {0}'.format(e))
            traceback.print_exc()
            IS_RUNNING = False
            return 1

        self.log('closing connection.')
        hpc.close()
        return 0

def startThreads():
    threads=[]
    global databaseQueue, socketQueue, IS_RUNNING

    IS_RUNNING = True

    t = Thread(target=hpfeedsThread)
    t.daemon = True
    threads.append(t)
    t.start()

    t = Thread(target=databaseThread)
    t.daemon = True
    threads.append(t)
    t.start()

    t = Thread(target=socketThread)
    t.daemon = True
    threads.append(t)
    t.start()

    try:
        for t in threads:
            t.join()
    except:
        traceback.print_exc()
        IS_RUNNING = False

if __name__ == '__main__' :
    startThreads()
