#!/usr/bin/env python
# -- coding: utf-8 --
import sys
import os
sPath=os.path.dirname(os.path.realpath(__file__))+'/'
sys.path.append(sPath+'../')
from malwarez_util import initPath

initPath()

import json
import string
import traceback
from Queue import Queue, Empty, Full
import threading
from threading import Thread
from socketIO_client import SocketIO
import freegeoip
import hpfeeds

socketIOHost = '127.0.0.1'
socketIOPort = 80

# Set the DJANGO_SETTINGS_MODULE environment variable.
os.environ['DJANGO_SETTINGS_MODULE'] = "malwarez.settings"
from web.models import Feed

IS_RUNNING = None
client = None

databaseQueue = Queue(250)
socketQueue = Queue(250)

threads=[]

def socketThread():
    """
    Reads the socketQueue and fill the geo location info(lat, long, city, country) then send new updated
    data to server. After sending to server put the updated feed object to databaseQueue
    """
    global socketQueue, databaseQueue, IS_RUNNING, socketIOHost, socketIOPort

    def _sendNewFeed(chatSocket, newFeed):
        info = freegeoip.getCityInfoByIp(newFeed.saddr)
        if info:
            newFeed.longitude = info['longitude']
            newFeed.latitude = info['latitude']
            newFeed.country = info['country_code3']

            city = info['city']
            if city:
                try:
                    city = city.decode('utf-8', 'ignore')
                except:
                    city = ''

                newFeed.city = city

            coordinate = "{ \"country\":\"%s\", \"city\":\"%s\", \"x\": \"%f\", \"y\": \"%f\"}" % (newFeed.country, newFeed.city, info['longitude'], info['latitude'])
            chatSocket.emit('update', coordinate)
            databaseQueue.put(newFeed)

    try:
        socketIO = SocketIO(socketIOHost, socketIOPort)
        chatSocket = socketIO.connect('/new-event')
        print 'socketThread started, IS_RUNNING:', IS_RUNNING
        while IS_RUNNING:
            try:
                newFeed = socketQueue.get(True, 1)
                _sendNewFeed(chatSocket, newFeed)
                socketQueue.task_done()
            except Empty:
                pass
    except:
        IS_RUNNING = False

    print 'socketThread finished...'


def databaseThread():
    """
    Reads the databaseQueue and save the object to db. After the operation object will be discarded.
    """
    global databaseQueue, IS_RUNNING

    print 'databaseThread started, IS_RUNNING:', IS_RUNNING
    while IS_RUNNING:
        try:
            newFeed = databaseQueue.get(True, 1)
            newFeed.save()
            databaseQueue.task_done()
            del newFeed
        except Empty:
            pass
        except:
            break
            #stopExecution()
    print 'databaseThread finished...'


def hpfeedsThread():
    global socketQueue, IS_RUNNING, client
    accountFile = open(sPath+'hpfriends.json', 'r')
    account = json.load(accountFile)

    opts = {
        'IDENT': str(account['user']),
        'SECRET': str(account['pass']),
        'HOST': str(account['host']),
        'PORT': account['port'],
        'CHANNELS': account['capture']
    }

    client = FeedClient(opts)
    print 'hpfeedsThread started, IS_RUNNING:', IS_RUNNING
    try:
        client.run()
    except:
        print 'client.run() exception'
        traceback.print_exc()


    IS_RUNNING = False
    print 'finishing hpfeedsThread'


class FeedClient():
    """
    This class is responsible for fetching new feeds from hpfriends and sends it to socketQueue
    """
    def __init__(self, opts):
        self.host = opts['HOST']
        self.port = opts['PORT']
        self.ident = opts['IDENT']
        self.secret = opts['SECRET']
        self.channels = opts['CHANNELS']
        self.hpc = None

    def log(self, text):
        # TODO: Replace this function with a proper logging function
        print 'log:', text

    def stop(self):
        if self.hpc:
            self.hpc.stop()
            self.hpc.close()

    def run(self):
        """
        Fetches feed from hpfriends and create a Feed object then put it to socketQueue
        """
        global IS_RUNNING

        try:
            self.hpc = hpfeeds.new(self.host, self.port, self.ident, self.secret)
        except hpfeeds.FeedException, e:
            self.log('Error: {0}'.format(e))
            return 1
        self.log('connected to {0}'.format(self.hpc.brokername))

        def on_message(ident, chan, payload):
            global databaseQueue, socketQueue
            if [i for i in payload[:20] if i not in string.printable]:
                # TODO: Can be improved?
                pass
            else:
                payload = "{0}".format(payload)
                data = json.loads(payload)
                del payload
                newFeed = Feed(url=data['url'], daddr=data['daddr'],
                                saddr=data['saddr'], sport=data['sport'],
                                dport=data['dport'], sha512=data['sha512'],
                                md5=data['md5'], longitude=-1,
                                latitude=-1, city=u'', country=u'')

                socketQueue.put(newFeed)

        def on_error(payload):
            self.log('Error message from broker: {0}'.format(payload))
            self.hpc.stop()

        self.hpc.subscribe(self.channels)
        try:
            self.hpc.run(on_message, on_error)
        except hpfeeds.FeedException, e:
            self.log('Error: {0}'.format(e))
            traceback.print_exc()
            IS_RUNNING = False
            return 1

        self.log('closing connection.')
        self.hpc.close()
        return 0


def startThreads():
    global databaseQueue, socketQueue, IS_RUNNING, threads

    IS_RUNNING = True

    t = Thread(target=hpfeedsThread)
    t.daemon = True
    threads.append(t)
    t.start()

    t = Thread(target=databaseThread)
    t.daemon = True
    threads.append(t)
    t.start()

    t = Thread(target=socketThread)
    t.daemon = True
    threads.append(t)
    t.start()

    return threads


stopExecutionStartedFlag = False;
stopLock = None

def stopExecution():
    # TODO: This must be thread
    global socketQueue, databaseQueue, IS_RUNNING, client, threads, stopExecutionStartedFlag, stopLock

    stopLock.acquire()
    if stopExecutionStartedFlag:
        # Already executed, No need to repeat
        stopLock.release()
        return
    stopExecutionStartedFlag = True
    stopLock.release()
    IS_RUNNING = False
    if client:
        print 'stopping client...'
        client.stop()

    print 'waiting...'
    try:
        for t in threads:
            t.join()
    except:
        traceback.print_exc()

    print 'del...'
    del databaseQueue
    del socketQueue



if __name__ == '__main__' :
    import signal

    stopLock = threading.Lock()

    def signal_handler(signal, frame):
        print 'You pressed Ctrl+C!'
        stopExecution()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    print 'Press Ctrl+C to stop'
    threads = startThreads()
    signal.pause()