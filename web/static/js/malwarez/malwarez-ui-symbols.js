var MalwarezSymbols = function(){

    var _sumOfFrequency = 0;

    function _drawBar(map, x, y, d) {
        var tooltipTitle = '';
        var tooltipText = '';

        var x1 = 0;
        var y1 = 0;
        /* TODO: calculate next point */
        _drawShape(map, x, y, x1, y1, tooltipTitle, tooltipText);
    }

    function _drawPoint(map, x, y, shapeColor) {
        var tooltipTitle = '';
        var tooltipText = ''; //'Text x: ' + x + ' y: ' + y;
        var s = _drawShape(map, x, y, x, y, tooltipTitle, tooltipText, shapeColor);
        setTimeout(function(){s.remove()},3000);
    }

    function _drawShape(map, x, y, x1, y1, tooltipTitle, tooltipText, shapeColor) {
        x = x - 70;
        x1 = x1 - 70;

        var src = new Array(x, y);
        var dst = new Array(x1, y1);
        var shape = map.addGeoPath([src, dst]);

        if(!shapeColor) {
            shapeColor = '#800';
        }

        shape.attr({
            stroke: shapeColor,
            opacity:.50,
            'stroke-width': 5,
            fill: shapeColor,
            'stroke-linecap': 'round'
        });

        if (Raphael.svg) {
            setTimeout(function() {
                $(shape.node).qtip({
                    content: {
                        title: tooltipTitle,
                        text: tooltipText
                    },
                    position: {
                        target: 'mouse',
                        viewport: $(window),
                        adjust: { x:7, y:7}
                    }
                }, 0);
            }, 0);

        } else {
            shape.attr('path', map.getGeoPathStr(pts));
        }

        return shape;
    }

    function _showGrid(map) {
        var i, j;
        for(j=-90; j<=90; j+=10) {
            for(i=-180; i<=180; i+=10) {
                _drawPoint(map, i, j);
            }
        }
    }

    /*
     worldMap.addSymbols({
     type: $K.Label,
     data: [{ name: 'Zero', lon: (26.96 - 70), lat: 38.23 }],
     location: function(d) { return [d.lon, d.lat] },
     text: function(d) { return d.name; }
     });
     */

    var _addActivityData = function(d) {
        if(! MalwarezSymbols.activityDataSetCountryIndex.hasOwnProperty(d.country)) {
            MalwarezSymbols.activityDataSetCountryIndex[d.country] = [];
        }
        MalwarezSymbols.activityDataSetCountryIndex[d.country].push(d);
        MalwarezSymbols.activityDataSetIndex[d.id] = d;
        MalwarezSymbols.activityDataSet.push(d);
        _sumOfFrequency += d.freq;
    }

    var _getDataByCountryCode = function(countryCode) {
        if(MalwarezSymbols.activityDataSetCountryIndex.hasOwnProperty(countryCode)) {
            return MalwarezSymbols.activityDataSetCountryIndex[countryCode];
        } else {
            return null;
        }
    }

    var _getDataById = function(id){
        if(MalwarezSymbols.activityDataSetIndex.hasOwnProperty(id)) {
            return MalwarezSymbols.activityDataSetIndex[id];
        } else {
            return null;
        }
    }

    function __activitySymbolAttrs(data){
        var key = 'freq';
        return { r: Math.sqrt(data[key]/_sumOfFrequency) * 30 };
    }

    // get an json of [{'city':'Izmir', 'freq':40, 'latlong':[38.2381801, 26.9604492]}, {'city':'Berlin', 'freq':50, 'latlong':[52.5233, 13.4127]} ]
    function _drawActivities(map, key) {

        function __arrayUnique(array) {
            var a = array.concat();
            for(var i=0; i<a.length; ++i) {
                for(var j=i+1; j<a.length; ++j) {
                    if(a[i] === a[j])
                        a.splice(j--, 1);
                }
            }
            return a;
        };

        MalwarezSymbols.activitySymbols = map.addSymbols({
            type: $K.Bubble,
            data: MalwarezSymbols.activityDataSet,

            clustering: 'noverlap',
            aggregate: function (data) {
                    var nc = { };
                    nc[key] = 0;
                    nc.country = '';
                    nc.country_codes = [];
                    $.each(data, function(i, d) {
                        nc[key] += d[key];
                        nc.country_codes = __arrayUnique(nc.country_codes.concat(d.country_codes ? d.country_codes : [d.country]));
                    });
                    nc.country = nc.country_codes[0];
                    return nc;
            },
            location: function(d) { return [d.longlat[0]-70 , d.longlat[1]] },
            attrs: __activitySymbolAttrs,
            radius: function(data) { return __activitySymbolAttrs(data).r},
            sortBy: 'radius desc',
            style: 'fill:#800; stroke: #800; fill-opacity: 0.5;',
            tooltip: function(d) { return '#of activity: ' + d[key]; },
            click: function(data, symbol, event) {
                event.stopPropagation();
                console.log('symbol clicked. data: ' + JSON.stringify(data))
                if(data.country_codes) {

                    if(data.country_codes.length > 1) {
                        MalwarezPopup.prompt('Which country you would like to open?', data.country_codes, function(response) {
                            console.log('response: ' + response);
                            if(response) {
                                Malwarez.openCountryMap(response);
                            }
                        });
                    } else{
                        Malwarez.openCountryMap(data.country_codes[0]);
                    }
                } else {
                    Malwarez.openCountryMap(data.country);
                }
            }
        });
    }

    function __updateActivitiesMap(map, key, newData) {
        MalwarezSymbols.drawPoint(map, newData.longlat[0], newData.longlat[1], '#FFFF00');
        // get data
        var updatedData = MalwarezSymbols.getDataById(newData.id);

        if(updatedData) {
            updatedData.freq += 1;
            _sumOfFrequency += 1;
        } else {
            // TODO: Check if this approach correct or not
            MalwarezSymbols.addActivityData(newData);
            var s = MalwarezSymbols.activitySymbols.add(newData);
            var xy = map.lonlat2xy(s.location);
            s.x = xy[0]
            s.y = xy[1]
            s.render();
            //console.info('layout-after', $('circle').length, MalwarezSymbols.activitySymbols.symbols.length, MalwarezSymbols.activitySymbols.osymbols.length);
        }

        MalwarezSymbols.activitySymbols.update({
            attrs: __activitySymbolAttrs,
            radius: function(data) { return __activitySymbolAttrs(data).r}
        });
        console.log('activity map updated.');
    }

    var barGraphMap;
    var barGraphKey;
    var barGraphDataset;
    var barGraphDatasetIndex;
    var barGraphSymbols;
    var barGraphSymbolsIndex;
    function _drawBarGraph(map, dataset, key) {
        barGraphMap=map;
        barGraphKey=key;
        barGraphSymbolsIndex={};
        barGraphSymbols = [];
        barGraphDataset = dataset;
        barGraphDatasetIndex = {};
        __drawBars(map, barGraphDataset, key);
    }

    function _updateBarGraph(data) {
        if(data.id in barGraphSymbolsIndex) {
            barGraphDatasetIndex[data.id].freq++;
        } else {
            var d = new Object({"id" : data.id, "freq" : 1, "city" : data.city, "longlat": [data.x, data.y]});
            barGraphDatasetIndex[data.id]=d;
            barGraphDataset.push(d);
        }
        __drawBars(barGraphMap, barGraphDataset, barGraphKey);
    }

    function __drawBars(map, dataset, key) {
        var scale = $K.scale.linear(dataset, key);

        $.each(dataset, function(index, d) {
            var bar, pts;
            var x= d.longlat[0];
            var y = d.longlat[1];
            var ll = [x, y];

            pts = [ll, [x, y, scale(d[key])*100]];

            if (barGraphSymbols[index]) {
                /* If we will support multiple key based graph features this is useful otherwise remove this part. */
                bar = barGraphSymbols[index];
                if (Raphael.svg) bar.animate({ path: map.getGeoPathStr(pts) }, 500);
                else bar.attr('path', map.getGeoPathStr(pts));

                // Update the tooltip content
                $(bar.node).qtip('option', 'content.text', '# of activities: ' + d[key]);
            } else {
                bar = map.addGeoPath([ll,ll]);
                bar.attr({
                    stroke: '#024',
                    opacity: .5,
                    'stroke-width': 4,
                    fill: 'none',
                    'stroke-linecap': 'square'
                });
                if (Raphael.svg) {
                    bar.animate({ path: map.getGeoPathStr(pts) }, 500);
                    bar.node.setAttribute('title', d.city);

                    setTimeout(function() {
                        $(bar.node).qtip({
                            content: {
                                title: d.city,
                                text: '# of activities: ' + d[key]
                            },
                            position: {
                                target: 'mouse',
                                viewport: $(window),
                                adjust: { x:7, y:7}
                            }
                        }, 800);
                    });

                } else {
                    bar.attr('path', map.getGeoPathStr(pts));
                }
                barGraphSymbols.push(bar);
                barGraphSymbolsIndex[d.id] = bar;
                barGraphDatasetIndex[d.id] = d;
            }
        });
    }

    return new Object({
        drawBar         : _drawBar,
        drawPoint       : _drawPoint,
        drawShape       : _drawShape,
        showGrid        : _showGrid,
        drawActivities  : _drawActivities,
        drawBarGraph    : _drawBarGraph,
        updateActivitiesMap : __updateActivitiesMap,
        updateBarGraph  : _updateBarGraph,
        activityDataSet : [],
        activityDataSetIndex : {},
        activityDataSetCountryIndex : {},
        activitySymbols : null,
        addActivityData : _addActivityData,
        getDataByCountryCode : _getDataByCountryCode,
        getDataById : _getDataById
    });
}();