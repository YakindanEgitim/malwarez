var MalwarezSymbols = function(){

    function _drawBar(map, x, y, d) {
        var tooltipTitle = '';
        var tooltipText = '';

        var x1 = 0;
        var y1 = 0;
        /* TODO: calculate next point */
        _drawShape(map, x, y, x1, y1, tooltipTitle, tooltipText);
    }

    function _drawPoint(map, x, y, shapeColor) {
        var tooltipTitle = '';
        var tooltipText = 'Text x: ' + x + ' y: ' + y;
        _drawShape(map, x, y, x, y, tooltipTitle, tooltipText, shapeColor);
    }

    function _drawShape(map, x, y, x1, y1, tooltipTitle, tooltipText, shapeColor) {
        x = x - 70;
        x1 = x1 - 70;

        var src = new Array(x, y);
        var dst = new Array(x1, y1);
        var shape = map.addGeoPath([src, dst]);

        if(!shapeColor) {
            shapeColor = '#800';
        }

        shape.attr({
            stroke: shapeColor,
            opacity:.50,
            'stroke-width': 5,
            fill: shapeColor,
            'stroke-linecap': 'round'
        });

        if (Raphael.svg) {
            setTimeout(function() {
                $(shape.node).qtip({
                    content: {
                        title: tooltipTitle,
                        text: tooltipText
                    },
                    position: {
                        target: 'mouse',
                        viewport: $(window),
                        adjust: { x:7, y:7}
                    }
                }, 0);
            }, 0);

        } else {
            shape.attr('path', map.getGeoPathStr(pts));
        }

        return shape;
    }

    function _showGrid(map) {
        var i, j;
        for(j=-90; j<=90; j+=10) {
            for(i=-180; i<=180; i+=10) {
                _drawPoint(map, i, j);
            }
        }
    }

    /*
     worldMap.addSymbols({
     type: $K.Label,
     data: [{ name: 'Zero', lon: (26.96 - 70), lat: 38.23 }],
     location: function(d) { return [d.lon, d.lat] },
     text: function(d) { return d.name; }
     });
     */

    // get an json of [{'city':'Izmir', 'freq':40, 'latlong':[38.2381801, 26.9604492]}, {'city':'Berlin', 'freq':50, 'latlong':[52.5233, 13.4127]} ]
    function _drawActivities(map, dataset, key) {
        dataset.forEach(function(d) {MalwarezSymbols.activityDataSet.push(d)});

        //console.log('_activityDataSet: ' + _activityDataSet);

        var scale = $K.scale.linear(MalwarezSymbols.activityDataSet, key);
        //var colscale = chroma.scale(chroma.brewer.PiYG.slice().reverse());
/*
        function __symbolAttrs(data) {
           return {
              r: Math.sqrt(scale(data[key])) * 12  // radius in pixel
              //fill: colscale(scale(data[key]))  // color using chroma.js
           };
        }
*/
        MalwarezSymbols.activitySymbols = map.addSymbols({
            type: $K.Bubble,
            data: MalwarezSymbols.activityDataSet,
            location: function(d) { return [d.longlat[0]-70 , d.longlat[1]] },
            attrs: function(data) { return {r: Math.sqrt(scale(data[key])) * 12  /*, fill: colscale(scale(data[key]))*/};},//__symbolAttrs,
            sortBy: 'radius desc',
            style: 'fill:#800; stroke: #800; fill-opacity: 0.5;',
            tooltip: function(d) { return '#of activity: ' + d[key]; }
        });

        // This should be called with each socket.io update
        //__updateMap();
    }

    function __updateActivitiesMap(key) {
        var scale = $K.scale.linear(MalwarezSymbols.activityDataSet, key);
        //console.log('activityDataSet.length: '  + MalwarezSymbols.activityDataSet.length);

        MalwarezSymbols.activitySymbols.update({
            data : MalwarezSymbols.activityDataSet,
            attrs: function(data) {
                return {
                    r: Math.sqrt(scale(data[key])) * 12
                };
            }//__symbolAttrs,
        }, true /* 500,'backOut' */);
    }

    var barGraphMap;
    var barGraphKey;
    var barGraphDataset;
    var barGraphDatasetIndex;
    var barGraphSymbols;
    var barGraphSymbolsIndex;
    function _drawBarGraph(map, dataset, key) {
        barGraphMap=map;
        barGraphKey=key;
        barGraphSymbolsIndex={};
        barGraphSymbols = [];
        barGraphDataset = dataset;
        barGraphDatasetIndex = {};
        __drawBars(map, barGraphDataset, key);
    }

    function _updateBarGraph(data) {
        //console.log('barGraphDataset: ' + barGraphDataset);
        if(data.id in barGraphSymbolsIndex) {
            barGraphDatasetIndex[data.id].freq++;
        } else {
            var d = new Object({"id" : data.id, "freq" : 1, "city" : data.city, "longlat": [data.x, data.y]});
            barGraphDatasetIndex[data.id]=d;
            barGraphDataset.push(d);
        }
        __drawBars(barGraphMap, barGraphDataset, barGraphKey);
    }

    function __drawBars(map, dataset, key) {
        scale = $K.scale.linear(dataset, key);

        $.each(dataset, function(index, d) {
            var bar, pts;
            var x= d.longlat[0];
            var y = d.longlat[1];
            var ll = [x, y];

            //console.log('x: ' + x + ' y: ' + y + ' d: ' + d.freq );
            pts = [ll, [x, y, scale(d[key])*100]];

            if (barGraphSymbols[index]) {
                /* If we will support multiple key based graph features this is useful otherwise remove this part. */
                bar = barGraphSymbols[index];
                if (Raphael.svg) bar.animate({ path: map.getGeoPathStr(pts) }, 500);
                else bar.attr('path', map.getGeoPathStr(pts));
            } else {
                bar = map.addGeoPath([ll,ll]);
                bar.attr({
                    stroke: '#024',
                    opacity: .5,
                    'stroke-width': 4,
                    fill: 'none',
                    'stroke-linecap': 'square'
                });
                if (Raphael.svg) {
                    bar.animate({ path: map.getGeoPathStr(pts) }, 500);
                    bar.node.setAttribute('title', d.city);

                    setTimeout(function() {
                        $(bar.node).qtip({
                            content: {
                                title: d.city,
                                text: '# of activities: ' + d[key]
                            },
                            position: {
                                target: 'mouse',
                                viewport: $(window),
                                adjust: { x:7, y:7}
                            }
                        }, 800);
                    });

                } else {
                    bar.attr('path', map.getGeoPathStr(pts));
                }
                barGraphSymbols.push(bar);
                barGraphSymbolsIndex[d.id] = bar;
                barGraphDatasetIndex[d.id] = d;
            }
        });
    }

    return new Object({
        drawBar         : _drawBar,
        drawPoint       : _drawPoint,
        drawShape       : _drawShape,
        showGrid        : _showGrid,
        drawActivities  : _drawActivities,
        drawBarGraph    : _drawBarGraph,
        updateActivitiesMap : __updateActivitiesMap,
        updateBarGraph  : _updateBarGraph,
        activityDataSet : [],
        activitySymbols : null
    });
}();