//Skeleton code for NewMap features
var ActivityMap;

$(function() {

    function checkParam(d, v) {
        if(d) { return d; }
        else  { return v; }
    }

    // constructor
    ActivityMap = function(map, data, layer, key)  {
        var me = this;

        me.map = map;
        me.layer = checkParam(layer, 'countries');
        me.key = checkParam(key, 'freq');

        me._sumOfFrequency = 0;
        me.activityDataSet = [];
        me.activityDataSetIndex = {};
        me.activityDataSetCountryIndex = {};
        me.activitySymbols = null;

        var me = this;
        $.each(data.objects, function(i, d) {
            /* Simple indexing for socket.io updates */
           me.addActivityData(d);
        });

        me.__getData =
            function (_index, dataProperty) {
                if(_index.hasOwnProperty(dataProperty)) {
                    return _index[dataProperty];
                } else {
                    return null;
                }
            };

        me.__activitySymbolAttrs =
            function (d){
                return { r: Math.sqrt(d[me.key]/me._sumOfFrequency) * 30 };
            };
    }

    // Initialize the symbols and
    ActivityMap.prototype.init = function() {
        /* initialize new symbols/data or whatever necessary */
        var me = this;
        function __arrayUnique(array) {
            var a = array.concat();
            for(var i=0; i<a.length; ++i) {
                for(var j=i+1; j<a.length; ++j) {
                    if(a[i] === a[j])
                        a.splice(j--, 1);
                }
            }
            return a;
        };

        var key = me.key;
        me.activitySymbols = me.map.addSymbols({
            type: $K.Bubble,
            data: me.activityDataSet,
            clustering: 'noverlap',
            aggregate: function (data) {
                    var nc = { };
                    nc[key] = 0;
                    nc.country = '';
                    nc.country_codes = [];
                    $.each(data, function(i, d) {
                        nc[key] += d[key];
                        nc.country_codes = __arrayUnique(nc.country_codes.concat(d.country_codes ? d.country_codes : [d.country]));
                    });
                    nc.country = nc.country_codes[0];
                    return nc;
            },
            location: function(d) { return [d.longlat[0]-70 , d.longlat[1]] },
            attrs: me.__activitySymbolAttrs,
            radius: function(d) { return me.__activitySymbolAttrs(d).r},
            sortBy: 'radius desc',
            style: 'fill:#800; stroke: #800; fill-opacity: 0.5;',
            tooltip: function(d) { return '#of activity: ' + d[key]; },
            click: function(data, symbol, event) {
                event.stopPropagation();
                //console.log('symbol clicked. data: ' + JSON.stringify(data));
                if(data.country_codes) {
                    if(data.country_codes.length > 1) {
                        MalwarezPopup.prompt('Which country you would like to open?', data.country_codes, function(response) {
                            console.log('response: ' + response);
                            if(response) {
                                Malwarez.openCountryMap(response);
                            }
                        });
                    } else{
                        Malwarez.openCountryMap(data.country_codes[0]);
                    }
                } else {
                    Malwarez.openCountryMap(data.country);
                }
            }
        });

        //initMapFeature();
        me.map.getLayer(me.layer).on(  'mouseenter',
                    function(data, path, event) {
                        path.attr("fill", "#FF0000");
                    });

        me.map.getLayer(me.layer).on(  'mouseleave',
                    function(data, path, event) {
                        path.attr("fill", "#ABC");
                    });
    }

    // Clear all symbols
    ActivityMap.prototype.clean = function() {
        var me = this;
        /* Cleanup function. remove all symbols or wahtever created during init method */
        console.log('ActivityMap.clean()');
        // Remove all symbols...
        me.activitySymbols.remove(function(d){ return true; });

        /* Clear/Override callback functions */

        var paths = me.map.getLayer(me.layer).paths;
        for(var i=0; i<paths.length; i++) {
            var path = paths[i];
            $(path.svgPath.node).unbind('mouseenter');
            $(path.svgPath.node).unbind('mouseleave');
        }
    }

    ActivityMap.prototype.addActivityData = function(d) {
        var me = this;
        if(! me.activityDataSetCountryIndex.hasOwnProperty(d.country)) {
            me.activityDataSetCountryIndex[d.country] = [];
        }
        me.activityDataSetCountryIndex[d.country].push(d);
        me.activityDataSetIndex[d.id] = d;
        me.activityDataSet.push(d);
        me._sumOfFrequency += d.freq;
    }

    ActivityMap.prototype.getDataByCountryCode = function(countryCode) {
        var _index = this.activityDataSetCountryIndex;
        return this.__getData(_index, countryCode);
    }

    ActivityMap.prototype.getDataById = function(id){
        var _index = this.activityDataSetIndex;
        return this.__getData(_index, id);
    }



    // Add new event to existing map and update the symbols
    ActivityMap.prototype.addEvent = function(newData) {
        /* add new data and render new symbols or trigger update for old ones */
        var me = this;
        MalwarezSymbols.drawPoint(me.map, newData.longlat[0], newData.longlat[1], '#FFFF00');

        // get data
        var updatedData = me.getDataById(newData.id);
        if(updatedData) {
            updatedData.freq += 1;
            me._sumOfFrequency += 1;
        } else {
            // TODO: Check if this approach correct or not
            me.addActivityData(newData);
            var s = me.activitySymbols.add(newData);
            var xy = me.map.lonlat2xy(s.location);
            s.x = xy[0]
            s.y = xy[1]
            s.render();
            //console.info('layout-after', $('circle').length, MalwarezSymbols.activitySymbols.symbols.length, MalwarezSymbols.activitySymbols.osymbols.length);
            me.update();
        }
    }

    // Update map
    ActivityMap.prototype.update = function() {
        /* update old ones */
        var me = this;
        me.activitySymbols.update({
            attrs: me.__activitySymbolAttrs,
            radius: function(d) { return me.__activitySymbolAttrs(d).r}
        });
        console.log('activity map updated.');
    }
});
